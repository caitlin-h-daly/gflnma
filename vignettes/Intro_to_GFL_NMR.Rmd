---
title: "Introduction to GFL-NMR"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Introduction to GFL-NMR}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(gflnma)
library(netmeta)
```

First, let's inspect the data.

```{r}
head(dat_afib)
```

For each study m comparing T_m treatments, all T_m([T_m]-1)/2 contrasts are reported. The treatments are compared in terms of the observed the rate of patients who experienced a stroke, which is calculated as event/exposure, where event = 'number of patients who experienced a stroke' and exposure = 'total patient years at risk'. The relative effect measure (`TE`) is the log rate ratio.

The covariate we will adjust for is proportion of patients with prior stroke (`stroke`).

# Inspect network

```{r}
# Check to see if it is connected
(netcon_check <- netmeta::netconnection(dat_afib, treat1 = treat1, treat2 = treat2, studlab = studlab))

# Plot network diagram
netmeta::netgraph(netcon_check)
```

Note there are 16 unique treatments + the reference treatment (01). We will adjust for a single covariate, proportion of patients with prior stroke; however, there are p*(T-1) = 16 treatment-specific covariate interaction terms in a full model.

# Derive GFL-NMR inputs

## Data clean up and rescaling matrix

To ensure there are no redudant data in the dataframe, and to obtain the variance-covariance matrix of the observed relative effects, apply the `prep_gfl_data()` to the data. Here, we fit a multiplicative effects model to capture any between-study heterogeneity by specifying `modtype = "ME"` within `prep_gfl_data()`. 

```{r}
dat_list <- prep_gfl_data(dat = dat_afib, 
                          TE = "TE",
                          seTE = "seTE", 
                          treatment1 = "treat1", 
                          treatment2 = "treat2",
                          studlab = "studlab",
                          event1 = "event1", 
                          time1 = "time1",
                          modtype = "ME")

head(dat <- dat_list$dat)

head(var_cov <- dat_list$var_cov)

(mod_type <- dat_list$mod_type)
```

Note that the data frame now only contains (T_m - 1) contrasts against a study-specific reference treatment for each study m. We can then extract a vector containing these contrasts, as well as the study-level summary statistics for the covariates we would like to adjust. Here, we will adjust for the proportion of patients who previous experienced a stroke, which is saved in the `stroke` column. Note that the covariate variables will be internally standardized by `solve_gflnma()` later while solving the GFL-NMR problem(s).

```{r}
# extract the relative effect estimates
y <- matrix(dat$TE, nrow = length(dat$TE), ncol = 1)

# extract the covariates
x_cov <- as.matrix(dat$stroke)
```

The `dat_list` also contains the variance-covariance matrix that will be used to weight the observed relative effect estimates, along with the model that the variance-covariance matrix corresponds to (FE or ME: var_cov = diag(study-specific var_cov), RE: var_cov = diag(study-specific var-cov + tau2_matrix)). 

## Design and penalty matrices

The `solve_gflnma()` function will internally derive the remaining inputs. Refer to the "How `gflnma` determines design and penalty matrices" vignette for an example on how to derive and inspect these inputs.

# Two-step GFL-NMR

As a first step, we will use GFL to allow the data to determine which treatment-covariate interaction terms should be selected and pooled. Then, we will fit a linear model using the GFL parameter configuration.

## Step One: Parameter Configuration

**Note `solve_gflnma()` internally calls on the `genlasso::genlasso()` function from the `genlasso` package. This function is used instead of the `genlasso::fusedlasso()` function as the former always enforces the ridge penalty, which is required to make the problem strictly convex and hence find a unique solution. The `fusedlasso()` function only enforces the ridge penalty when the design matrix has less rows than columns.

### Single problem

To solve a single GFL-NMR problem, the user simply calls on the `solve_gflnma()` function and specifies a single value for `gamma`. Note the ridge penalty multiplier may also be specified through `eps` to be larger than the default value of 0.0001. The ridge penalty is needed when there is not enough data points to estimate all parameters. The sparser the data, the more likely a larger ridge penalty is needed.

In this example, we solve the GFL-NMR problem by penalizing the d's and b's equally by specifying `gamma = 1`. We also specify the ridge penalty multiplier to be `eps = 0.5`. Each treatment receives its own interaction term because we have not specified a prior groupings through the `class1`, `class2`, and `ref_class` arguments. These may be considered if the user wanted to specify the shared effect modifier assumption to two or more specific treatments (e.g., because there is not enough evidence for one interaction term to be independently estimated. GFL-NMR, however, can group treatment-covariate interaction terms when this is the case, so the user need not do this). 

```{r}
# Solve GFL-NMR problem
mod <- solve_gflnma(y, var_cov, x_cov = x_cov, 
                    treatment1 = dat$treat1, 
                    treatment2 = dat$treat2, 
                    ref = "1",
                    class1 = NULL, class2 = NULL, ref_class = NULL,
                    minlam = 0, gamma = 1, eps = 0.5,
                    center = TRUE, rescale = TRUE)
```

We can summarize the solution path with `tabulate_solution_path()`. 

```{r}
# Summarize GFL-NMR model fit statistics
(mod_sum <- tabulate_solution_path(mod$solution, par_groups = mod$par_groups))
```

We can plot the solution plot using the `genlasso_path_plot()` function.

```{r}
# Note to user: The solution path should be plotted to check for extreme values, which may suggest a larger ridge penalty is needed
plot_solution_path(gfl_soln = mod$solution[[1]], 
                   gfl_sum = mod_sum$mod_sum_list[[1]], 
                   lambda_scale = 1, 
                   xlimits = c(-0.5, 5),
                   #ylimits = c(-1, 0.5),
                   par_groups = mod$par_groups)
```

To select a sensible parameter pooling configuration (as determined by lambda), we recommend examining the corrected AIC (AICc). The model that has deltaAICc = 0 has the smallest AICc.

```{r}
best_mod_index <- which(mod_sum$mod_sum_df[, "deltaAICc"] == 0)
(best_groups <- mod_sum$mod_sum_df[best_mod_index, ]$PooledGroups)
```
This model suggests treatment's 2-10, 12, and 14-16 have similar treatment effects, while the others are sufficiently different from the others. All treatment-level covariate interaction terms are shrunk to 0 apart from that of treatment 2 and treatment 15.

Note that it possible to only penalize the treatment-level covariate interaction terms by specifying `gamma = Inf` in `solve_gflnma()`. `Inf` implies we want to penalize the treatment-level covariate interaction terms infinitely more times than the relative effects.

```{r}
# Solve GFL-NMR problem
mod <- solve_gflnma(y, var_cov, x_cov = x_cov, 
                    treatment1 = dat$treat1, 
                    treatment2 = dat$treat2, 
                    ref = "1",
                    class1 = NULL, class2 = NULL, ref_class = NULL,
                    minlam = 0, gamma = Inf, eps = 0.5,
                    center = TRUE, scale = TRUE)

# Summarize GFL-NMR model fit statistics
mod_sum <- tabulate_solution_path(mod$solution, par_groups = mod$par_groups)

mod_sum$mod_sum_df
```

Plot the solution plot using the `genlasso_path_plot()` function.

```{r}
# Note to user: The solution path should be plotted to check for extreme values, which may suggest a larger ridge penalty is needed
plot_solution_path(gfl_soln = mod$solution[[1]], 
                   gfl_sum = mod_sum$mod_sum_list[[1]], 
                   lambda_scale = 1, 
                   xlimits = c(-0.5, 5),
                   #ylimits = c(-1, 0.5),
                   par_groups = mod$par_groups)
```

Note that all d's are separated, and the solution path of d is only plotted up to the lambda value at which the b's are fully pooled and shrunk to 0.

### Multiple problems

We will now vary the ridge multiplier (`eps`) and the ratio of penalty factors (`gamma` = penalty_beta / penalty_d).

```{r}
gamma <- c(Inf, seq(0.5, 2, by=0.5))
eps <- c(0.01, 0.1, 0.5)

mod <- solve_gflnma(y, 
                    var_cov, 
                    x_cov = x_cov, 
                    treatment1 = dat$treat1, 
                    treatment2 = dat$treat2, 
                    ref = "1", 
                    gamma = gamma, 
                    eps = eps,
                    center = TRUE,
                    scale = TRUE)
```

Let's summarize the results. 

```{r}

mod_sum <- tabulate_solution_path(mod$solution, 
                                      penfit_digits = 3,
                                      par_groups = mod$par_groups)

head(mod_sum_df <- mod_sum$mod_sum_df)

mod_sum_list <- mod_sum$mod_sum_list

```

We can then determine which model has the best AICc. 

```{r}
(best_model_index <- find_best_gfl(mod_sum$mod_sum_list, mod_sum_df, "AICc"))
```

Sometimes due to rounding, multiple models will appear to have a `deltaAICc = 0`. Examine all possible candidates and select a specific one.

```{r}
# Note to user: Inspect the table and select the model you prefer
selected_gflnma <- mod$solution[[best_model_index[1]]]
(selected_gflnma_sum <- mod_sum_list[[best_model_index[1]]])
```

We can plot the solution plot using the `genlasso_path_plot()` function for a specific pair of gamma and eps.

```{r}
# Note to user: The solution path should be plotted to check for extreme values, which may suggest a larger ridge penalty is needed
plot_solution_path(gfl_soln = selected_gflnma, 
                   gfl_sum = selected_gflnma_sum, 
                   lambda_scale = 1, 
                   xlimits = c(-0.5, 5),
                   #ylimits = c(-1, 0.5),
                   par_groups = mod$par_groups)
```

```{r}
# Note to user: Inspect the table and select the model you prefer
selected_gflnma_sum[which(selected_gflnma_sum["deltaAICc"] == 0), ]$PooledGroups
```

The best model suggests the effects of treatments 1 and 6 should be pooled, as well as treatments 2-4, 7-10, 12, 14-17. Only treatment-level covariate-interaction terms should be estimated for treatments 8, 11&12 (pooled), and 14.

## Step Two: NMR

Let's now fit an NMR model with this parameter configuration.

### Parameter coding

First re-code the treatments and treatment-covariate interactions

```{r}
best_lambda <- round(selected_gflnma_sum[which(selected_gflnma_sum["deltaAICc"]==0), ]$lambda, 3)
best_param_est <- selected_gflnma$beta[, paste0(best_lambda)]

dat <- recode_gfl_params(param_est = best_param_est, 
                         gfl_dat = dat, 
                         par_groups = mod$par_groups)
```

### Design matricies

We can build separate design matrices for the d's and beta's by using the `get_design_matrix()` and `get_cov_design_matrix()` function to create separate matrices for the treatment-specific relative effects (d's) and the treatment-covariate interaction terms, respectively, and then binding them.

```{r}
# determine the design matrix ('01' as reference) for treatment contrasts
X_d = get_design_matrix(dat$treat1_gfl, dat$treat2_gfl, ref = "1") 
# determine the design matrix ('Control' as reference) for treatment-covariate interaction terms
X_b <- gflnma:::get_cov_design_matrix(x_cov, 
                                      class1 = dat$treat1_beta1_gfl, 
                                      class2 = dat$treat2_beta1_gfl, 
                                      ref = "1",
                                      center = TRUE,
                                      rescale = TRUE)
X_gfl = cbind(X_d, X_b)
colnames(X_gfl) <- c(paste0("d_", 1:ncol(X_d) + 1), 
                     paste0("b", 1:dim(x_cov)[2], "_", 1:ncol(X_b) + 1))
head(X_gfl)
```

### Fit the model

We can now fit a multiplicative model using the lm() function.

```{r}
U <- chol(solve(var_cov))

mod_gfl <- lm(U%*%y ~ -1 + U%*%X_gfl)
summary(mod_gfl)
```
#### Validation

Let's now ensure the GFL-NMR estimates match what we can get from other NMR functions. Difficult to validate a multiplicative model against a FE or RE model...

##### Frequentist

To be done with netmeta::netmetareg() when available. As long as it allows class effects for interactions.

##### Bayesian

To be done with multinma.
